# å®‰å…¨æœºåˆ¶å¼ºåŒ–å®æ–½æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜æ™ºæ…§æ ¡å›­ç®¡ç†ç³»ç»Ÿçš„å®‰å…¨æœºåˆ¶å¼ºåŒ–æ–¹æ¡ˆï¼ŒåŒ…æ‹¬APIé™æµã€å®‰å…¨å®¡è®¡æ—¥å¿—å’ŒIPç™½åå•åŠŸèƒ½ã€‚

## ğŸ¯ å®‰å…¨ç›®æ ‡

- ğŸš¦ å®ç°APIé™æµæœºåˆ¶ï¼Œé˜²æ­¢æ¶æ„æ”»å‡»å’Œç³»ç»Ÿè¿‡è½½
- ğŸ“ å»ºç«‹å®Œå–„çš„å®‰å…¨å®¡è®¡æ—¥å¿—ç³»ç»Ÿ
- ğŸ›¡ï¸ å®ç°IPç™½åå•åŠŸèƒ½ï¼Œå¢å¼ºè®¿é—®æ§åˆ¶
- ğŸ” å¢å¼ºå®‰å…¨ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
- ğŸ” å¼ºåŒ–æ•°æ®ä¼ è¾“å’Œå­˜å‚¨å®‰å…¨

## ğŸ—ï¸ å®‰å…¨æ¶æ„

```
å®‰å…¨é˜²æŠ¤ä½“ç³»
â”œâ”€â”€ è®¿é—®æ§åˆ¶å±‚
â”‚   â”œâ”€â”€ IPç™½åå•
â”‚   â”œâ”€â”€ ç”¨æˆ·è®¤è¯
â”‚   â”œâ”€â”€ æƒé™éªŒè¯
â”‚   â””â”€â”€ ä¼šè¯ç®¡ç†
â”œâ”€â”€ é™æµé˜²æŠ¤å±‚
â”‚   â”œâ”€â”€ APIé™æµ
â”‚   â”œâ”€â”€ ç”¨æˆ·é™æµ
â”‚   â”œâ”€â”€ IPé™æµ
â”‚   â””â”€â”€ å¹¶å‘æ§åˆ¶
â”œâ”€â”€ å®¡è®¡ç›‘æ§å±‚
â”‚   â”œâ”€â”€ è®¿é—®æ—¥å¿—
â”‚   â”œâ”€â”€ æ“ä½œå®¡è®¡
â”‚   â”œâ”€â”€ å®‰å…¨äº‹ä»¶
â”‚   â””â”€â”€ å¼‚å¸¸å‘Šè­¦
â””â”€â”€ æ•°æ®å®‰å…¨å±‚
    â”œâ”€â”€ ä¼ è¾“åŠ å¯†
    â”œâ”€â”€ å­˜å‚¨åŠ å¯†
    â”œâ”€â”€ æ•æ„Ÿæ•°æ®è„±æ•
    â””â”€â”€ æ•°æ®å¤‡ä»½
```

## ğŸš¦ APIé™æµæœºåˆ¶å®ç°

### 1. é™æµä¾èµ–é…ç½®

```xml
<!-- pom.xml æ·»åŠ é™æµç›¸å…³ä¾èµ– -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<dependency>
    <groupId>com.github.vladimir-bukhtoyarov</groupId>
    <artifactId>bucket4j-core</artifactId>
    <version>7.6.0</version>
</dependency>
<dependency>
    <groupId>com.github.vladimir-bukhtoyarov</groupId>
    <artifactId>bucket4j-redis</artifactId>
    <version>7.6.0</version>
</dependency>
```

### 2. é™æµé…ç½®

```yaml
# application.yml æ–°å¢é™æµé…ç½®
campus:
  rate-limit:
    enabled: true
    # å…¨å±€é™æµé…ç½®
    global:
      requests-per-minute: 1000
      requests-per-hour: 10000
    
    # APIçº§åˆ«é™æµé…ç½®
    api:
      # ç™»å½•æ¥å£é™æµ
      login:
        requests-per-minute: 10
        requests-per-hour: 100
        block-duration-minutes: 15
      
      # æ³¨å†Œæ¥å£é™æµ
      register:
        requests-per-minute: 5
        requests-per-hour: 20
        block-duration-minutes: 30
      
      # æ–‡ä»¶ä¸Šä¼ é™æµ
      file-upload:
        requests-per-minute: 20
        requests-per-hour: 200
        max-file-size: 100MB
      
      # æ•°æ®å¯¼å‡ºé™æµ
      data-export:
        requests-per-minute: 2
        requests-per-hour: 10
        block-duration-minutes: 60
    
    # ç”¨æˆ·çº§åˆ«é™æµ
    user:
      # æ™®é€šç”¨æˆ·é™æµ
      normal:
        requests-per-minute: 100
        requests-per-hour: 1000
      
      # VIPç”¨æˆ·é™æµ
      vip:
        requests-per-minute: 200
        requests-per-hour: 2000
      
      # ç®¡ç†å‘˜é™æµ
      admin:
        requests-per-minute: 500
        requests-per-hour: 5000
    
    # IPçº§åˆ«é™æµ
    ip:
      requests-per-minute: 200
      requests-per-hour: 2000
      blacklist-threshold: 1000  # è¶…è¿‡æ­¤é˜ˆå€¼è‡ªåŠ¨åŠ å…¥é»‘åå•
      blacklist-duration-hours: 24
    
    # Redisé…ç½®
    redis:
      key-prefix: "rate_limit:"
      expire-time: 3600  # 1å°æ—¶
```

### 3. é™æµæ³¨è§£å®šä¹‰

```java
// ä½ç½®ï¼šsrc/main/java/com/campus/shared/security/RateLimit.java
package com.campus.shared.security;

import java.lang.annotation.*;
import java.util.concurrent.TimeUnit;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RateLimit {
    
    /**
     * é™æµé”®å
     */
    String key() default "";
    
    /**
     * é™æµç±»å‹
     */
    LimitType type() default LimitType.IP;
    
    /**
     * é™æµæ¬¡æ•°
     */
    int count() default 100;
    
    /**
     * é™æµæ—¶é—´çª—å£
     */
    int time() default 60;
    
    /**
     * æ—¶é—´å•ä½
     */
    TimeUnit timeUnit() default TimeUnit.SECONDS;
    
    /**
     * é™æµæç¤ºä¿¡æ¯
     */
    String message() default "è®¿é—®è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•";
    
    /**
     * æ˜¯å¦å¯ç”¨
     */
    boolean enabled() default true;
    
    /**
     * é™æµç±»å‹æšä¸¾
     */
    enum LimitType {
        /**
         * æ ¹æ®IPé™æµ
         */
        IP,
        
        /**
         * æ ¹æ®ç”¨æˆ·é™æµ
         */
        USER,
        
        /**
         * æ ¹æ®APIé™æµ
         */
        API,
        
        /**
         * è‡ªå®šä¹‰é™æµ
         */
        CUSTOM
    }
}
```

### 4. é™æµåˆ‡é¢å®ç°

```java
// ä½ç½®ï¼šsrc/main/java/com/campus/shared/security/RateLimitAspect.java
package com.campus.shared.security;

import com.campus.shared.exception.RateLimitException;
import com.campus.shared.util.SecurityUtil;
import com.campus.shared.util.WebUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.RedisScript;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.concurrent.TimeUnit;

@Slf4j
@Aspect
@Component
@RequiredArgsConstructor
public class RateLimitAspect {

    private final RedisTemplate<String, Object> redisTemplate;
    
    // Luaè„šæœ¬å®ç°åŸå­æ€§é™æµ
    private static final String RATE_LIMIT_SCRIPT = 
        "local key = KEYS[1] " +
        "local limit = tonumber(ARGV[1]) " +
        "local expire = tonumber(ARGV[2]) " +
        "local current = redis.call('GET', key) " +
        "if current == false then " +
        "    redis.call('SET', key, 1) " +
        "    redis.call('EXPIRE', key, expire) " +
        "    return 1 " +
        "elseif tonumber(current) < limit then " +
        "    return redis.call('INCR', key) " +
        "else " +
        "    return -1 " +
        "end";

    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint point, RateLimit rateLimit) throws Throwable {
        if (!rateLimit.enabled()) {
            return point.proceed();
        }

        String key = generateKey(point, rateLimit);
        
        // æ‰§è¡Œé™æµæ£€æŸ¥
        Long result = executeRateLimitScript(key, rateLimit.count(), rateLimit.time());
        
        if (result == -1) {
            // è®°å½•é™æµäº‹ä»¶
            logRateLimitEvent(key, rateLimit);
            throw new RateLimitException(rateLimit.message());
        }
        
        // è®°å½•è®¿é—®æ—¥å¿—
        logAccessEvent(key, result, rateLimit);
        
        return point.proceed();
    }

    private String generateKey(ProceedingJoinPoint point, RateLimit rateLimit) {
        StringBuilder keyBuilder = new StringBuilder("rate_limit:");
        
        switch (rateLimit.type()) {
            case IP:
                keyBuilder.append("ip:").append(WebUtil.getClientIp());
                break;
            case USER:
                Long userId = SecurityUtil.getCurrentUserId();
                keyBuilder.append("user:").append(userId != null ? userId : "anonymous");
                break;
            case API:
                keyBuilder.append("api:").append(point.getSignature().getName());
                break;
            case CUSTOM:
                keyBuilder.append("custom:").append(rateLimit.key());
                break;
        }
        
        if (!rateLimit.key().isEmpty()) {
            keyBuilder.append(":").append(rateLimit.key());
        }
        
        return keyBuilder.toString();
    }

    private Long executeRateLimitScript(String key, int limit, int expire) {
        RedisScript<Long> script = RedisScript.of(RATE_LIMIT_SCRIPT, Long.class);
        return redisTemplate.execute(script, 
                Collections.singletonList(key), 
                String.valueOf(limit), 
                String.valueOf(expire));
    }

    private void logRateLimitEvent(String key, RateLimit rateLimit) {
        log.warn("Rate limit exceeded - Key: {}, Limit: {}, Time: {}s, IP: {}, User: {}", 
                key, rateLimit.count(), rateLimit.time(), 
                WebUtil.getClientIp(), SecurityUtil.getCurrentUsername());
        
        // å‘é€å‘Šè­¦é€šçŸ¥
        sendRateLimitAlert(key, rateLimit);
    }

    private void logAccessEvent(String key, Long currentCount, RateLimit rateLimit) {
        if (log.isDebugEnabled()) {
            log.debug("Rate limit check - Key: {}, Current: {}, Limit: {}, IP: {}, User: {}", 
                    key, currentCount, rateLimit.count(), 
                    WebUtil.getClientIp(), SecurityUtil.getCurrentUsername());
        }
    }

    private void sendRateLimitAlert(String key, RateLimit rateLimit) {
        // å®ç°å‘Šè­¦é€»è¾‘ï¼Œå¦‚å‘é€é‚®ä»¶ã€çŸ­ä¿¡ç­‰
        // å¯ä»¥é›†æˆé’‰é’‰ã€ä¼ä¸šå¾®ä¿¡ç­‰å³æ—¶é€šè®¯å·¥å…·
    }
}
```

### 5. é™æµç®¡ç†æœåŠ¡

```java
// ä½ç½®ï¼šsrc/main/java/com/campus/application/service/RateLimitService.java
package com.campus.application.service;

import com.campus.application.dto.RateLimitInfo;
import com.campus.application.dto.RateLimitRule;

import java.util.List;

public interface RateLimitService {
    
    /**
     * è·å–é™æµä¿¡æ¯
     */
    RateLimitInfo getRateLimitInfo(String key);
    
    /**
     * é‡ç½®é™æµè®¡æ•°
     */
    void resetRateLimit(String key);
    
    /**
     * æ·»åŠ IPåˆ°é»‘åå•
     */
    void addToBlacklist(String ip, long durationHours, String reason);
    
    /**
     * ä»é»‘åå•ç§»é™¤IP
     */
    void removeFromBlacklist(String ip);
    
    /**
     * æ£€æŸ¥IPæ˜¯å¦åœ¨é»‘åå•
     */
    boolean isBlacklisted(String ip);
    
    /**
     * è·å–é»‘åå•åˆ—è¡¨
     */
    List<String> getBlacklistIps();
    
    /**
     * è·å–é™æµè§„åˆ™
     */
    List<RateLimitRule> getRateLimitRules();
    
    /**
     * æ›´æ–°é™æµè§„åˆ™
     */
    void updateRateLimitRule(RateLimitRule rule);
    
    /**
     * è·å–é™æµç»Ÿè®¡
     */
    RateLimitStatistics getRateLimitStatistics();
}
```

## ğŸ“ å®‰å…¨å®¡è®¡æ—¥å¿—ç³»ç»Ÿ

### 1. å®¡è®¡æ—¥å¿—å®ä½“

```java
// ä½ç½®ï¼šsrc/main/java/com/campus/domain/entity/system/SecurityAuditLog.java
package com.campus.domain.entity.system;

import com.campus.domain.entity.infrastructure.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.time.LocalDateTime;

@Data
@EqualsAndHashCode(callSuper = true)
@Entity
@Table(name = "tb_security_audit_log")
public class SecurityAuditLog extends BaseEntity {

    /**
     * ç”¨æˆ·ID
     */
    @Column(name = "user_id")
    private Long userId;

    /**
     * ç”¨æˆ·å
     */
    @Column(name = "username", length = 50)
    private String username;

    /**
     * æ“ä½œç±»å‹
     */
    @Column(name = "operation_type", length = 50, nullable = false)
    private String operationType;

    /**
     * æ“ä½œæè¿°
     */
    @Column(name = "operation_desc", length = 200)
    private String operationDesc;

    /**
     * èµ„æºç±»å‹
     */
    @Column(name = "resource_type", length = 50)
    private String resourceType;

    /**
     * èµ„æºID
     */
    @Column(name = "resource_id", length = 100)
    private String resourceId;

    /**
     * HTTPæ–¹æ³•
     */
    @Column(name = "http_method", length = 10)
    private String httpMethod;

    /**
     * è¯·æ±‚URL
     */
    @Column(name = "request_url", length = 500)
    private String requestUrl;

    /**
     * è¯·æ±‚å‚æ•°
     */
    @Column(name = "request_params", columnDefinition = "TEXT")
    private String requestParams;

    /**
     * å®¢æˆ·ç«¯IP
     */
    @Column(name = "client_ip", length = 50)
    private String clientIp;

    /**
     * ç”¨æˆ·ä»£ç†
     */
    @Column(name = "user_agent", columnDefinition = "TEXT")
    private String userAgent;

    /**
     * æ“ä½œç»“æœ
     */
    @Column(name = "operation_result", length = 20)
    private String operationResult;

    /**
     * é”™è¯¯ä¿¡æ¯
     */
    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;

    /**
     * æ‰§è¡Œæ—¶é•¿(æ¯«ç§’)
     */
    @Column(name = "execution_time")
    private Long executionTime;

    /**
     * é£é™©ç­‰çº§
     */
    @Column(name = "risk_level", length = 20)
    private String riskLevel;

    /**
     * æ“ä½œæ—¶é—´
     */
    @Column(name = "operation_time", nullable = false)
    private LocalDateTime operationTime;

    // æ“ä½œç±»å‹æšä¸¾
    public enum OperationType {
        LOGIN("ç™»å½•"),
        LOGOUT("ç™»å‡º"),
        CREATE("åˆ›å»º"),
        UPDATE("æ›´æ–°"),
        DELETE("åˆ é™¤"),
        QUERY("æŸ¥è¯¢"),
        EXPORT("å¯¼å‡º"),
        IMPORT("å¯¼å…¥"),
        UPLOAD("ä¸Šä¼ "),
        DOWNLOAD("ä¸‹è½½"),
        CONFIG_CHANGE("é…ç½®å˜æ›´"),
        PERMISSION_CHANGE("æƒé™å˜æ›´");

        private final String description;

        OperationType(String description) {
            this.description = description;
        }

        public String getDescription() {
            return description;
        }
    }

    // æ“ä½œç»“æœæšä¸¾
    public enum OperationResult {
        SUCCESS("æˆåŠŸ"),
        FAILURE("å¤±è´¥"),
        PARTIAL_SUCCESS("éƒ¨åˆ†æˆåŠŸ");

        private final String description;

        OperationResult(String description) {
            this.description = description;
        }

        public String getDescription() {
            return description;
        }
    }

    // é£é™©ç­‰çº§æšä¸¾
    public enum RiskLevel {
        LOW("ä½"),
        MEDIUM("ä¸­"),
        HIGH("é«˜"),
        CRITICAL("ä¸¥é‡");

        private final String description;

        RiskLevel(String description) {
            this.description = description;
        }

        public String getDescription() {
            return description;
        }
    }
}
```

### 2. å®¡è®¡æ—¥å¿—æ³¨è§£

```java
// ä½ç½®ï¼šsrc/main/java/com/campus/shared/security/AuditLog.java
package com.campus.shared.security;

import java.lang.annotation.*;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface AuditLog {
    
    /**
     * æ“ä½œç±»å‹
     */
    String operationType();
    
    /**
     * æ“ä½œæè¿°
     */
    String description() default "";
    
    /**
     * èµ„æºç±»å‹
     */
    String resourceType() default "";
    
    /**
     * é£é™©ç­‰çº§
     */
    RiskLevel riskLevel() default RiskLevel.LOW;
    
    /**
     * æ˜¯å¦è®°å½•è¯·æ±‚å‚æ•°
     */
    boolean logParams() default true;
    
    /**
     * æ˜¯å¦è®°å½•å“åº”ç»“æœ
     */
    boolean logResult() default false;
    
    /**
     * æ˜¯å¦å¼‚æ­¥è®°å½•
     */
    boolean async() default true;
    
    enum RiskLevel {
        LOW, MEDIUM, HIGH, CRITICAL
    }
}
```

### 3. å®¡è®¡æ—¥å¿—åˆ‡é¢

```java
// ä½ç½®ï¼šsrc/main/java/com/campus/shared/security/AuditLogAspect.java
package com.campus.shared.security;

import com.campus.application.service.SecurityAuditLogService;
import com.campus.domain.entity.system.SecurityAuditLog;
import com.campus.shared.util.JsonUtil;
import com.campus.shared.util.SecurityUtil;
import com.campus.shared.util.WebUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import jakarta.servlet.http.HttpServletRequest;
import java.time.LocalDateTime;
import java.util.Arrays;

@Slf4j
@Aspect
@Component
@RequiredArgsConstructor
public class AuditLogAspect {

    private final SecurityAuditLogService auditLogService;

    @Around("@annotation(auditLog)")
    public Object around(ProceedingJoinPoint point, AuditLog auditLog) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = null;
        Exception exception = null;

        try {
            result = point.proceed();
            return result;
        } catch (Exception e) {
            exception = e;
            throw e;
        } finally {
            long executionTime = System.currentTimeMillis() - startTime;
            
            if (auditLog.async()) {
                saveAuditLogAsync(point, auditLog, result, exception, executionTime);
            } else {
                saveAuditLog(point, auditLog, result, exception, executionTime);
            }
        }
    }

    @Async
    public void saveAuditLogAsync(ProceedingJoinPoint point, AuditLog auditLog, 
                                 Object result, Exception exception, long executionTime) {
        saveAuditLog(point, auditLog, result, exception, executionTime);
    }

    private void saveAuditLog(ProceedingJoinPoint point, AuditLog auditLog, 
                             Object result, Exception exception, long executionTime) {
        try {
            SecurityAuditLog log = new SecurityAuditLog();
            
            // åŸºæœ¬ä¿¡æ¯
            log.setUserId(SecurityUtil.getCurrentUserId());
            log.setUsername(SecurityUtil.getCurrentUsername());
            log.setOperationType(auditLog.operationType());
            log.setOperationDesc(auditLog.description());
            log.setResourceType(auditLog.resourceType());
            log.setExecutionTime(executionTime);
            log.setOperationTime(LocalDateTime.now());
            
            // è¯·æ±‚ä¿¡æ¯
            HttpServletRequest request = getCurrentRequest();
            if (request != null) {
                log.setHttpMethod(request.getMethod());
                log.setRequestUrl(request.getRequestURL().toString());
                log.setClientIp(WebUtil.getClientIp(request));
                log.setUserAgent(request.getHeader("User-Agent"));
                
                // è®°å½•è¯·æ±‚å‚æ•°
                if (auditLog.logParams()) {
                    log.setRequestParams(JsonUtil.toJson(Arrays.asList(point.getArgs())));
                }
            }
            
            // æ“ä½œç»“æœ
            if (exception != null) {
                log.setOperationResult(SecurityAuditLog.OperationResult.FAILURE.name());
                log.setErrorMessage(exception.getMessage());
            } else {
                log.setOperationResult(SecurityAuditLog.OperationResult.SUCCESS.name());
            }
            
            // é£é™©ç­‰çº§
            log.setRiskLevel(auditLog.riskLevel().name());
            
            // ä¿å­˜å®¡è®¡æ—¥å¿—
            auditLogService.saveAuditLog(log);
            
        } catch (Exception e) {
            log.error("ä¿å­˜å®¡è®¡æ—¥å¿—å¤±è´¥", e);
        }
    }

    private HttpServletRequest getCurrentRequest() {
        ServletRequestAttributes attributes = 
            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        return attributes != null ? attributes.getRequest() : null;
    }
}
```

## ğŸ›¡ï¸ IPç™½åå•åŠŸèƒ½

### 1. IPç™½åå•å®ä½“

```java
// ä½ç½®ï¼šsrc/main/java/com/campus/domain/entity/system/IpWhitelist.java
package com.campus.domain.entity.system;

import com.campus.domain.entity.infrastructure.BaseEntity;
import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.time.LocalDateTime;

@Data
@EqualsAndHashCode(callSuper = true)
@Entity
@Table(name = "tb_ip_whitelist")
public class IpWhitelist extends BaseEntity {

    /**
     * IPåœ°å€æˆ–IPæ®µ
     */
    @Column(name = "ip_address", nullable = false, length = 50)
    private String ipAddress;

    /**
     * IPç±»å‹ï¼šSINGLE-å•ä¸ªIPï¼ŒRANGE-IPæ®µï¼ŒCIDR-CIDRæ ¼å¼
     */
    @Column(name = "ip_type", nullable = false, length = 20)
    private String ipType;

    /**
     * æè¿°
     */
    @Column(name = "description", length = 200)
    private String description;

    /**
     * æ˜¯å¦å¯ç”¨
     */
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;

    /**
     * ç”Ÿæ•ˆæ—¶é—´
     */
    @Column(name = "effective_time")
    private LocalDateTime effectiveTime;

    /**
     * è¿‡æœŸæ—¶é—´
     */
    @Column(name = "expire_time")
    private LocalDateTime expireTime;

    /**
     * åˆ›å»ºè€…ID
     */
    @Column(name = "created_by")
    private Long createdBy;

    /**
     * æœ€åè®¿é—®æ—¶é—´
     */
    @Column(name = "last_access_time")
    private LocalDateTime lastAccessTime;

    /**
     * è®¿é—®æ¬¡æ•°
     */
    @Column(name = "access_count", columnDefinition = "INT DEFAULT 0")
    private Integer accessCount = 0;

    // IPç±»å‹æšä¸¾
    public enum IpType {
        SINGLE("å•ä¸ªIP"),
        RANGE("IPæ®µ"),
        CIDR("CIDRæ ¼å¼");

        private final String description;

        IpType(String description) {
            this.description = description;
        }

        public String getDescription() {
            return description;
        }
    }
}
```

### 2. IPç™½åå•è¿‡æ»¤å™¨

```java
// ä½ç½®ï¼šsrc/main/java/com/campus/shared/security/IpWhitelistFilter.java
package com.campus.shared.security;

import com.campus.application.service.IpWhitelistService;
import com.campus.shared.util.WebUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Component
@RequiredArgsConstructor
public class IpWhitelistFilter extends OncePerRequestFilter {

    private final IpWhitelistService ipWhitelistService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        String clientIp = WebUtil.getClientIp(request);
        String requestUri = request.getRequestURI();
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦IPç™½åå•éªŒè¯
        if (needsIpWhitelistCheck(requestUri)) {
            if (!ipWhitelistService.isIpAllowed(clientIp)) {
                log.warn("IPè®¿é—®è¢«æ‹’ç» - IP: {}, URI: {}", clientIp, requestUri);
                
                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                response.setContentType("application/json;charset=UTF-8");
                response.getWriter().write("{\"code\":403,\"message\":\"IPè®¿é—®è¢«æ‹’ç»\"}");
                return;
            }
            
            // è®°å½•IPè®¿é—®
            ipWhitelistService.recordIpAccess(clientIp);
        }
        
        filterChain.doFilter(request, response);
    }

    private boolean needsIpWhitelistCheck(String requestUri) {
        // ç®¡ç†å‘˜æ¥å£éœ€è¦IPç™½åå•éªŒè¯
        if (requestUri.startsWith("/api/v1/admin/")) {
            return true;
        }
        
        // ç³»ç»Ÿé…ç½®æ¥å£éœ€è¦IPç™½åå•éªŒè¯
        if (requestUri.startsWith("/api/v1/system/config")) {
            return true;
        }
        
        // æ•°æ®å¯¼å‡ºæ¥å£éœ€è¦IPç™½åå•éªŒè¯
        if (requestUri.startsWith("/api/v1/data/export")) {
            return true;
        }
        
        return false;
    }
}
```

## ğŸ“‹ å®æ–½æ£€æŸ¥æ¸…å•

### âœ… APIé™æµå®æ–½
- [ ] æ·»åŠ é™æµä¾èµ–
- [ ] é…ç½®é™æµå‚æ•°
- [ ] å®ç°é™æµæ³¨è§£å’Œåˆ‡é¢
- [ ] åˆ›å»ºé™æµç®¡ç†æœåŠ¡
- [ ] é…ç½®Redisè¿æ¥
- [ ] æµ‹è¯•é™æµåŠŸèƒ½

### âœ… å®‰å…¨å®¡è®¡æ—¥å¿—
- [ ] åˆ›å»ºå®¡è®¡æ—¥å¿—è¡¨
- [ ] å®ç°å®¡è®¡æ—¥å¿—å®ä½“
- [ ] å¼€å‘å®¡è®¡æ—¥å¿—åˆ‡é¢
- [ ] é…ç½®å¼‚æ­¥å¤„ç†
- [ ] å®ç°æ—¥å¿—æŸ¥è¯¢æ¥å£
- [ ] é…ç½®æ—¥å¿—å½’æ¡£

### âœ… IPç™½åå•åŠŸèƒ½
- [ ] åˆ›å»ºIPç™½åå•è¡¨
- [ ] å®ç°IPç™½åå•å®ä½“
- [ ] å¼€å‘IPéªŒè¯è¿‡æ»¤å™¨
- [ ] å®ç°IPç®¡ç†æ¥å£
- [ ] é…ç½®è¿‡æ»¤å™¨é¡ºåº
- [ ] æµ‹è¯•IPè®¿é—®æ§åˆ¶

### âœ… ç›‘æ§å‘Šè­¦
- [ ] é…ç½®å®‰å…¨äº‹ä»¶ç›‘æ§
- [ ] å®ç°å‘Šè­¦é€šçŸ¥
- [ ] é›†æˆç›‘æ§å¹³å°
- [ ] é…ç½®å‘Šè­¦è§„åˆ™

## ğŸ“ˆ å®‰å…¨æŒ‡æ ‡

| å®‰å…¨æŒ‡æ ‡ | ç›®æ ‡å€¼ | ç›‘æ§æ–¹å¼ |
|----------|--------|----------|
| APIé™æµæˆåŠŸç‡ | > 99% | Redisç›‘æ§ |
| å®¡è®¡æ—¥å¿—å®Œæ•´æ€§ | 100% | æ•°æ®åº“ç›‘æ§ |
| IPç™½åå•å‘½ä¸­ç‡ | > 95% | è®¿é—®æ—¥å¿—åˆ†æ |
| å®‰å…¨äº‹ä»¶å“åº”æ—¶é—´ | < 5åˆ†é’Ÿ | å‘Šè­¦ç³»ç»Ÿ |
| å¼‚å¸¸è®¿é—®æ‹¦æˆªç‡ | > 98% | å®‰å…¨ç›‘æ§ |

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœ‰é—®é¢˜ï¼Œè¯·è”ç³»ï¼š
- å®‰å…¨è´Ÿè´£äººï¼š[å§“å]
- åç«¯è´Ÿè´£äººï¼š[å§“å]
- é‚®ç®±ï¼š[é‚®ç®±åœ°å€]
